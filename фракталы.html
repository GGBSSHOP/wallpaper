<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>á…Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            height: 100vh;
        }
        
        #fractalCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="fractalCanvas"></canvas>

    <script>
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        
        let currentFractal = 0;
        let cycleTime = 35;
        let timeCounter = 0;
        let animationId = null;
        let isPortraitMode = false;
        
        function checkOrientation() {
            isPortraitMode = window.innerHeight > window.innerWidth;
            return isPortraitMode;
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            checkOrientation();
        }
        
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        resizeCanvas();
        
        const colorSchemes = [
            ['#ff0000', '#00ff00', '#0000ff', '#ffff00'],
            ['#ff00ff', '#00ffff', '#ff9900', '#6600ff'],
            ['#ffffff', '#00ff88', '#ff0088', '#88ff00'],
            ['#000000', '#ff3300', '#33ff00', '#0066ff']
        ];
        
        function interpolateColor(color1, color2, factor) {
            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);
            
            const r2 = parseInt(color2.substring(1, 3), 16);
            const g2 = parseInt(color2.substring(3, 5), 16);
            const b2 = parseInt(color2.substring(5, 7), 16);
            
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function getGradientColor(colors, progress, time, depth) {
            const totalColors = colors.length;
            const colorIndex = (progress * totalColors + time * 0.0001 * depth) % totalColors;
            const baseIndex = Math.floor(colorIndex) % totalColors;
            const nextIndex = (baseIndex + 1) % totalColors;
            const factor = colorIndex - baseIndex;
            
            return interpolateColor(colors[baseIndex], colors[nextIndex], factor);
        }
        
        const fractals = [
            function(time) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const colors = colorSchemes[currentFractal % colorSchemes.length];
                const baseLength = Math.min(canvas.width, canvas.height) * 0.3;
                const depth = isPortraitMode ? 8 : 10;
                
                drawSmoothBranch(canvas.width/2, canvas.height, -Math.PI/2, baseLength, depth, 0, colors, time);
            },
            
            function(time) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const colors = colorSchemes[currentFractal % colorSchemes.length];
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for(let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) + time * 0.001;
                    const color = colors[i % colors.length];
                    drawSpiral(centerX, centerY, angle, 0.95, color, time);
                }
            },
            
            function(time) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const colors = colorSchemes[currentFractal % colorSchemes.length];
                const depth = isPortraitMode ? 6 : 7;
                const size = Math.min(canvas.width, canvas.height) * 0.7;
                
                for (let i = 0; i < 3; i++) {
                    const angle = (i * Math.PI * 2 / 3) + time * 0.0005;
                    const x = canvas.width/2 + Math.cos(angle) * size * 0.2;
                    const y = canvas.height/2 + Math.sin(angle) * size * 0.2;
                    
                    drawRotatingTriangleFractal(
                        x, y, 
                        size * 0.8, 
                        depth, 
                        colors, 
                        time,
                        angle * 2
                    );
                }
                
                drawComplexTriangleFractal(
                    canvas.width/2, canvas.height/2,
                    size * 0.5,
                    depth + 1,
                    colors,
                    time
                );
            }
        ];
        
        function drawSmoothBranch(x, y, angle, length, depth, branchNum, colors, time) {
            if(depth <= 0) return;
            
            const endX = x + Math.cos(angle) * length;
            const endY = y + Math.sin(angle) * length;
            
            const progress = (branchNum * 0.1 + time * 0.00005) % 1;
            const color = getGradientColor(colors, progress, time, depth);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = depth * (isPortraitMode ? 0.6 : 0.8);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            const newLength = length * (isPortraitMode ? 0.7 : 0.75);
            const angleVariation = Math.sin(time * 0.001 + depth + branchNum * 0.5) * 0.4;
            
            drawSmoothBranch(endX, endY, angle - Math.PI/4 + angleVariation, newLength, depth-1, branchNum+1, colors, time);
            drawSmoothBranch(endX, endY, angle + Math.PI/4 - angleVariation, newLength, depth-1, branchNum+2, colors, time);
            
            if (depth % 3 === 0) {
                const extraAngle = Math.sin(time * 0.002 + depth) * 0.5;
                drawSmoothBranch(endX, endY, angle + extraAngle, newLength * 0.6, depth-2, branchNum+3, colors, time);
            }
        }
        
        function drawSpiral(x, y, startAngle, scale, color, time) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let radius = 5;
            let angle = startAngle;
            
            for(let i = 0; i < 150; i++) {
                const posX = x + Math.cos(angle) * radius;
                const posY = y + Math.sin(angle) * radius;
                
                if(i === 0) {
                    ctx.moveTo(posX, posY);
                } else {
                    ctx.lineTo(posX, posY);
                }
                
                radius *= 1.05;
                angle += 0.1 + Math.sin(time * 0.002) * 0.05;
            }
            
            ctx.stroke();
        }
        
        function drawRotatingTriangleFractal(centerX, centerY, size, depth, colors, time, rotation) {
            if(depth <= 0) return;
            
            const angleOffset = rotation + time * 0.0003 * depth;
            
            const x1 = centerX + Math.cos(angleOffset) * size;
            const y1 = centerY + Math.sin(angleOffset) * size;
            
            const x2 = centerX + Math.cos(angleOffset + Math.PI * 2/3) * size;
            const y2 = centerY + Math.sin(angleOffset + Math.PI * 2/3) * size;
            
            const x3 = centerX + Math.cos(angleOffset + Math.PI * 4/3) * size;
            const y3 = centerY + Math.sin(angleOffset + Math.PI * 4/3) * size;
            
            const color = colors[depth % colors.length];
            ctx.fillStyle = color + Math.floor(100 + depth * 20).toString(16).padStart(2, '0');
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = color;
            ctx.lineWidth = depth * 0.3;
            ctx.stroke();
            
            const newSize = size * 0.5;
            const newRotation = rotation * 1.5 + 0.2;
            
            drawRotatingTriangleFractal(x1, y1, newSize, depth-1, colors, time, newRotation);
            drawRotatingTriangleFractal(x2, y2, newSize, depth-1, colors, time, newRotation);
            drawRotatingTriangleFractal(x3, y3, newSize, depth-1, colors, time, newRotation);
        }
        
        function drawComplexTriangleFractal(centerX, centerY, size, depth, colors, time) {
            if(depth <= 0) return;
            
            for(let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3 + time * 0.0002 * depth;
                const x = centerX + Math.cos(angle) * size * 0.6;
                const y = centerY + Math.sin(angle) * size * 0.6;
                
                const colorIndex = (depth + i) % colors.length;
                const color = colors[colorIndex];
                
                for(let j = 0; j < 3; j++) {
                    const triangleSize = size * (0.8 - j * 0.2);
                    const rotation = time * 0.0005 + j * 0.5;
                    
                    drawSingleRotatingTriangle(x, y, triangleSize, color, rotation);
                }
            }
            
            if(depth > 1) {
                drawComplexTriangleFractal(centerX, centerY, size * 0.4, depth-1, colors, time);
            }
        }
        
        function drawSingleRotatingTriangle(centerX, centerY, size, color, rotation) {
            ctx.save();
            
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);
            
            ctx.fillStyle = color + '66';
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.866, size * 0.5);
            ctx.lineTo(-size * 0.866, size * 0.5);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }
        
        function animate(time) {
            timeCounter++;
            
            if(timeCounter >= cycleTime * 60) {
                currentFractal = (currentFractal + 1) % fractals.length;
                timeCounter = 0;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            fractals[currentFractal](time);
            
            animationId = requestAnimationFrame(animate);
        }
        
        animate(0);
        
        window.addEventListener('beforeunload', () => {
            if(animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>